from ortools.constraint_solver import pywrapcp  # segfault happens if we wait to import this in the env file - TODO: figure out why
from ortools.linear_solver import pywraplp
import numpy as np
import os
import collections
import argparse
import uuid
import wandb
from os.path import dirname, abspath
from copy import deepcopy
import sys
import torch as th
from utils.logging import get_logger
import yaml

from run import run

logger = get_logger()
# hardcode configuration stuff we don't want to save to wandb here
wandb_ignore_params = [
    'use_tensorboard',
    'save_model',
    'save_model_interval',
    'checkpoint_run_name',
    'pi_checkpoint_run_name',
    'evaluate',
    'load_step',
    'save_replay',
    'video_path',
    'fps',
    'tb_dirname',
    'eval_all_scen',
    'eval_path',
    'agent_output_type',
    'mac',
    'env_args',
    'test_nepisode',
    'test_interval',
    'log_interval',
    'runner_log_interval',
    'learner_log_interval',
    'use_wandb',
    'wb_notes',
    'wb_tags',
]


def main(config):
    # Setting the random seed throughout the modules
    config['seed'] = np.random.randint(999999)
    np.random.seed(config["seed"])
    th.manual_seed(config["seed"])
    config['env_args']['seed'] = config["seed"]

    wandb_run = None
    # only create wandb logs for training
    if not (config['evaluate'] or config['save_replay']) and config['use_wandb']:
        wandb_config = deepcopy(config)
        for param in wandb_ignore_params:
            del wandb_config[param]
        wandb_run = wandb.init(
            project="task-allocation",
            entity=config['wb_entity'],
            notes=" ".join(config['wb_notes']),
            tags=config['wb_tags'],
            config=wandb_config,
            name=f"{config['name']}_{uuid.uuid4().hex[:6].upper()}"  # add unique ID for repeated runs of same exp name
        )
        wandb.save("*.th")  # will push saved models to the cloud immediately, rather than waiting until the end of training

    run(config, logger, wandb_run)

    # force exit
    os._exit(0)


def _get_config(params, arg_name, subfolder):
    config_name = None
    for _i, _v in enumerate(params):
        if _v.split("=")[0] == arg_name:
            config_name = _v.split("=")[1]
            del params[_i]
            break

    if config_name is not None:
        with open(os.path.join(os.path.dirname(__file__), "config", subfolder, "{}.yaml".format(config_name)), "r") as f:
            try:
                config_dict = yaml.load(f)
            except yaml.YAMLError as exc:
                assert False, "{}.yaml error: {}".format(config_name, exc)
        return config_dict


def recursive_dict_update(d, u):
    for k, v in u.items():
        if isinstance(v, collections.Mapping):
            d[k] = recursive_dict_update(d.get(k, {}), v)
        else:
            d[k] = v
    return d


def recursive_cli_gen(parser, defaults, bases=[]):
    """
    Generates CLI based on config files. All parameters default to the settings
    in the config files, but they can be overwritten w/ the CLI. Type is
    inferred from the type of the default values. Nested dictionaries are
    handled by joining the key of the parent dict and the key of the child dict
    with a ".". Ex: "--env_args.entity_scheme True"
    """
    for param, value in defaults.items():
        if isinstance(value, collections.Mapping):
            parser = recursive_cli_gen(parser, value,
                                       bases=bases + [param])
        else:
            if value is None:
                argtype = None
            elif type(value) is bool:
                # want to properly parse strings like "False" and "True"
                argtype = str_to_bool
            else:
                argtype = type(value)
            parser.add_argument(
                "--%s" % (".".join(bases + [param])),
                type=argtype,
                default=value)
    return parser


def str_to_bool(value):
    """
    https://stackoverflow.com/questions/52403065/argparse-optional-boolean
    """
    if isinstance(value, bool):
        return value
    if value.lower() in {'false', 'f', '0', 'no', 'n'}:
        return False
    elif value.lower() in {'true', 't', '1', 'yes', 'y'}:
        return True
    raise ValueError('{} is not a valid boolean value'.format(value))


def restore_nested_dicts(config_dict):
    """
    Restores nested dict structure from flat dict generated by arg parser
    """
    for param, value in list(config_dict.items()):  # convert items to list to allow modifying dict during iteration
        if "." in param:
            keys = param.split(".")
            curr_dict = config_dict
            for i in range(len(keys)):
                curr_key = keys[i]
                if i == len(keys) - 1:
                    curr_dict[curr_key] = value
                else:
                    if curr_key not in curr_dict:
                        curr_dict[curr_key] = {}
                    curr_dict = curr_dict[curr_key]
            # want to remove the keys that are converted to nested dicts
            del config_dict[param]
    return config_dict


if __name__ == '__main__':
    params = deepcopy(sys.argv)

    # Get the defaults from default.yaml
    with open(os.path.join(os.path.dirname(__file__), "config", "default.yaml"), "r") as f:
        try:
            defaults = yaml.load(f)
        except yaml.YAMLError as exc:
            assert False, "default.yaml error: {}".format(exc)

    # Load algorithm and env base configs, these will be used unless
    # overwritten by command line args
    env_config = _get_config(params, "--env-config", "envs")  # removes "--env-config" from params
    alg_config = _get_config(params, "--config", "algs")  # removes "--config" from params
    defaults = recursive_dict_update(defaults, env_config)  # overrides anything set in defaults
    defaults = recursive_dict_update(defaults, alg_config)  # overrides anything set in env_config or defaults

    # create command line interface with all available parameters in configs
    parser = argparse.ArgumentParser()
    parser = recursive_cli_gen(parser, defaults)
    # Weights & Biases
    parser.add_argument("--use-wandb", action="store_true",
                        help="Enable W&B logging")
    parser.add_argument("--wb-notes", nargs='+', default=list(),
                        help="Experimental notes (W&B)")
    parser.add_argument("--wb-tags", nargs="+", default=list(),
                        help="Experimental tags (W&B)")
    parser.add_argument("--wb-entity", type=str, default="entity",
                        help="Team or user name for weights and biases")
    config = parser.parse_args(params[1:]).__dict__  # cut out filename param
    config = restore_nested_dicts(config)

    main(config)
